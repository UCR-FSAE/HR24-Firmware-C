<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FSAE VCU Firmware V1.0: Pwm_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="NEW+FULL+HR+LOGO+WHITE-116w.webp"/></td>
  <td id="projectalign">
   <div id="projectname">FSAE VCU Firmware V1.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__pwm__api.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Pwm_api</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7fa2c9868b0c6fe74c9a90ade752130a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(_mod_,  _gen_)&#160;&#160;&#160;                                ((_mod_) + (_gen_))</td></tr>
<tr class="separator:ga7fa2c9868b0c6fe74c9a90ade752130a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf81b183094f6f00cb1108caec1d91e6b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gaf81b183094f6f00cb1108caec1d91e6b">PWM_GEN_EXT_BADDR</a>(_mod_,  _gen_)</td></tr>
<tr class="separator:gaf81b183094f6f00cb1108caec1d91e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4563e3820191c9d6e73156340b715264"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga4563e3820191c9d6e73156340b715264">PWM_OUT_BADDR</a>(_mod_,  _out_)&#160;&#160;&#160;                                ((_mod_) + ((_out_) &amp; 0xFFFFFFC0))</td></tr>
<tr class="separator:ga4563e3820191c9d6e73156340b715264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7904efa054c5e221ee9aa2e438f37100"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga7904efa054c5e221ee9aa2e438f37100">PWM_IS_OUTPUT_ODD</a>(_out_)&#160;&#160;&#160;                                ((_out_) &amp; 0x00000001)</td></tr>
<tr class="separator:ga7904efa054c5e221ee9aa2e438f37100"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4fb48f68ba82e698c6ce1913d5300754"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga4fb48f68ba82e698c6ce1913d5300754">PWMGenConfigure</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Config)</td></tr>
<tr class="separator:ga4fb48f68ba82e698c6ce1913d5300754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ec9d188f8e72f597f4f5bf41152468d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga0ec9d188f8e72f597f4f5bf41152468d">PWMGenPeriodSet</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Period)</td></tr>
<tr class="separator:ga0ec9d188f8e72f597f4f5bf41152468d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga318c7e9cfc0c4abc0c1efc3154bc0810"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga318c7e9cfc0c4abc0c1efc3154bc0810">PWMGenPeriodGet</a> (uint32_t ui32Base, uint32_t ui32Gen)</td></tr>
<tr class="separator:ga318c7e9cfc0c4abc0c1efc3154bc0810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac83fa6b41c14ed89bb8c1882c59ac190"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gac83fa6b41c14ed89bb8c1882c59ac190">PWMGenEnable</a> (uint32_t ui32Base, uint32_t ui32Gen)</td></tr>
<tr class="separator:gac83fa6b41c14ed89bb8c1882c59ac190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2829ffb434e65a7aa27ee69977fdc122"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga2829ffb434e65a7aa27ee69977fdc122">PWMGenDisable</a> (uint32_t ui32Base, uint32_t ui32Gen)</td></tr>
<tr class="separator:ga2829ffb434e65a7aa27ee69977fdc122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2abde7fc411bf9cad8de0c5dc070c78c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga2abde7fc411bf9cad8de0c5dc070c78c">PWMPulseWidthSet</a> (uint32_t ui32Base, uint32_t ui32PWMOut, uint32_t ui32Width)</td></tr>
<tr class="separator:ga2abde7fc411bf9cad8de0c5dc070c78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae361688d19da3c776f82e31607392f3f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gae361688d19da3c776f82e31607392f3f">PWMPulseWidthGet</a> (uint32_t ui32Base, uint32_t ui32PWMOut)</td></tr>
<tr class="separator:gae361688d19da3c776f82e31607392f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe610ec6fd50251becf382a1479ca32f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gabe610ec6fd50251becf382a1479ca32f">PWMDeadBandEnable</a> (uint32_t ui32Base, uint32_t ui32Gen, uint16_t ui16Rise, uint16_t ui16Fall)</td></tr>
<tr class="separator:gabe610ec6fd50251becf382a1479ca32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0330312868b4d7df496759563635690c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga0330312868b4d7df496759563635690c">PWMDeadBandDisable</a> (uint32_t ui32Base, uint32_t ui32Gen)</td></tr>
<tr class="separator:ga0330312868b4d7df496759563635690c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a04801267751f323f528cd3d5f2da5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga32a04801267751f323f528cd3d5f2da5">PWMSyncUpdate</a> (uint32_t ui32Base, uint32_t ui32GenBits)</td></tr>
<tr class="separator:ga32a04801267751f323f528cd3d5f2da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd7281936c715b7286746bbae6c24a6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gadd7281936c715b7286746bbae6c24a6a">PWMSyncTimeBase</a> (uint32_t ui32Base, uint32_t ui32GenBits)</td></tr>
<tr class="separator:gadd7281936c715b7286746bbae6c24a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga372c69ae52fe1136454b60230f38beb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga372c69ae52fe1136454b60230f38beb1">PWMOutputState</a> (uint32_t ui32Base, uint32_t ui32PWMOutBits, bool bEnable)</td></tr>
<tr class="separator:ga372c69ae52fe1136454b60230f38beb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf233159a77a070f2dc60d50da3939ba9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gaf233159a77a070f2dc60d50da3939ba9">PWMOutputInvert</a> (uint32_t ui32Base, uint32_t ui32PWMOutBits, bool bInvert)</td></tr>
<tr class="separator:gaf233159a77a070f2dc60d50da3939ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35b6c40b99278f7d78c186cd275b7a05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga35b6c40b99278f7d78c186cd275b7a05">PWMOutputFaultLevel</a> (uint32_t ui32Base, uint32_t ui32PWMOutBits, bool bDriveHigh)</td></tr>
<tr class="separator:ga35b6c40b99278f7d78c186cd275b7a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10e1cb93f663c916cf5403e29e1be898"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga10e1cb93f663c916cf5403e29e1be898">PWMOutputFault</a> (uint32_t ui32Base, uint32_t ui32PWMOutBits, bool bFaultSuppress)</td></tr>
<tr class="separator:ga10e1cb93f663c916cf5403e29e1be898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bd27374e6dce2e1a2689166b79be9f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga1bd27374e6dce2e1a2689166b79be9f6">PWMGenIntRegister</a> (uint32_t ui32Base, uint32_t ui32Gen, void(*pfnIntHandler)(void))</td></tr>
<tr class="separator:ga1bd27374e6dce2e1a2689166b79be9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c72c556d0febbd7d641df12f30d7b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga93c72c556d0febbd7d641df12f30d7b1">PWMGenIntUnregister</a> (uint32_t ui32Base, uint32_t ui32Gen)</td></tr>
<tr class="separator:ga93c72c556d0febbd7d641df12f30d7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada200e22c312dd4015e26717821ffb39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gada200e22c312dd4015e26717821ffb39">PWMFaultIntRegister</a> (uint32_t ui32Base, void(*pfnIntHandler)(void))</td></tr>
<tr class="separator:gada200e22c312dd4015e26717821ffb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5b9971717f517bdac7c1f1e3885e541"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gaa5b9971717f517bdac7c1f1e3885e541">PWMFaultIntUnregister</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:gaa5b9971717f517bdac7c1f1e3885e541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31055ec13555e774fa6702e35b774518"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga31055ec13555e774fa6702e35b774518">PWMGenIntTrigEnable</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32IntTrig)</td></tr>
<tr class="separator:ga31055ec13555e774fa6702e35b774518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdd8f3c8343e5b06916bb6ba5ead9533"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gafdd8f3c8343e5b06916bb6ba5ead9533">PWMGenIntTrigDisable</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32IntTrig)</td></tr>
<tr class="separator:gafdd8f3c8343e5b06916bb6ba5ead9533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga645372a9dd99a0683d7c8e53006357ed"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga645372a9dd99a0683d7c8e53006357ed">PWMGenIntStatus</a> (uint32_t ui32Base, uint32_t ui32Gen, bool bMasked)</td></tr>
<tr class="separator:ga645372a9dd99a0683d7c8e53006357ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d4748e1865ceae4814aef2296a9604a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga0d4748e1865ceae4814aef2296a9604a">PWMGenIntClear</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Ints)</td></tr>
<tr class="separator:ga0d4748e1865ceae4814aef2296a9604a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf66b481a351b0be5f06e163640319838"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gaf66b481a351b0be5f06e163640319838">PWMIntEnable</a> (uint32_t ui32Base, uint32_t ui32GenFault)</td></tr>
<tr class="separator:gaf66b481a351b0be5f06e163640319838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaca72e1bc8b2f041b6e6ad290d54a12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gacaca72e1bc8b2f041b6e6ad290d54a12">PWMIntDisable</a> (uint32_t ui32Base, uint32_t ui32GenFault)</td></tr>
<tr class="separator:gacaca72e1bc8b2f041b6e6ad290d54a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf389ca1c69300d556fdc5113cccf5060"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gaf389ca1c69300d556fdc5113cccf5060">PWMFaultIntClear</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:gaf389ca1c69300d556fdc5113cccf5060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac90f2873671ff65e9225d8238e068a14"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gac90f2873671ff65e9225d8238e068a14">PWMIntStatus</a> (uint32_t ui32Base, bool bMasked)</td></tr>
<tr class="separator:gac90f2873671ff65e9225d8238e068a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c0e721a969daed808a148607859e21d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga9c0e721a969daed808a148607859e21d">PWMFaultIntClearExt</a> (uint32_t ui32Base, uint32_t ui32FaultInts)</td></tr>
<tr class="separator:ga9c0e721a969daed808a148607859e21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16ca060d2c4e997682912cba1d6d1962"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga16ca060d2c4e997682912cba1d6d1962">PWMGenFaultConfigure</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32MinFaultPeriod, uint32_t ui32FaultSenses)</td></tr>
<tr class="separator:ga16ca060d2c4e997682912cba1d6d1962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7fb9968efcd45b0525dc1f3bca86819"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gae7fb9968efcd45b0525dc1f3bca86819">PWMGenFaultTriggerSet</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Group, uint32_t ui32FaultTriggers)</td></tr>
<tr class="separator:gae7fb9968efcd45b0525dc1f3bca86819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e1b382bd20206868f6bb0af0af98df"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga59e1b382bd20206868f6bb0af0af98df">PWMGenFaultTriggerGet</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Group)</td></tr>
<tr class="separator:ga59e1b382bd20206868f6bb0af0af98df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2cd851dc65dccee7c2c885f15bbfc4a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gaf2cd851dc65dccee7c2c885f15bbfc4a">PWMGenFaultStatus</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Group)</td></tr>
<tr class="separator:gaf2cd851dc65dccee7c2c885f15bbfc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c00a35459dd8714d57bb35c1b2e5621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga3c00a35459dd8714d57bb35c1b2e5621">PWMGenFaultClear</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Group, uint32_t ui32FaultTriggers)</td></tr>
<tr class="separator:ga3c00a35459dd8714d57bb35c1b2e5621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe29ab284505972d4c172e6b33daabd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gabe29ab284505972d4c172e6b33daabd9">PWMClockSet</a> (uint32_t ui32Base, uint32_t ui32Config)</td></tr>
<tr class="separator:gabe29ab284505972d4c172e6b33daabd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f57a49f895de360f84c363f608eebed"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga6f57a49f895de360f84c363f608eebed">PWMClockGet</a> (uint32_t ui32Base)</td></tr>
<tr class="separator:ga6f57a49f895de360f84c363f608eebed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77b64a04eb1bd9daf99c10d549a8ada5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga77b64a04eb1bd9daf99c10d549a8ada5">PWMOutputUpdateMode</a> (uint32_t ui32Base, uint32_t ui32PWMOutBits, uint32_t ui32Mode)</td></tr>
<tr class="separator:ga77b64a04eb1bd9daf99c10d549a8ada5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga7fa2c9868b0c6fe74c9a90ade752130a" name="ga7fa2c9868b0c6fe74c9a90ade752130a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fa2c9868b0c6fe74c9a90ade752130a">&#9670;&#160;</a></span>PWM_GEN_BADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PWM_GEN_BADDR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_mod_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_gen_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;                                ((_mod_) + (_gen_))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf81b183094f6f00cb1108caec1d91e6b" name="gaf81b183094f6f00cb1108caec1d91e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf81b183094f6f00cb1108caec1d91e6b">&#9670;&#160;</a></span>PWM_GEN_EXT_BADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PWM_GEN_EXT_BADDR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_mod_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_gen_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                ((_mod_) + <a class="code hl_define" href="pwm_8h.html#a949d66a43a7014ea1893875a343ed948">PWM_GEN_EXT_0</a> +                    \</div>
<div class="line">                                 ((_gen_) - <a class="code hl_define" href="pwm_8h.html#a9e2cd841eb589469e7f862b392d29088">PWM_GEN_0</a>) * 2)</div>
<div class="ttc" id="apwm_8h_html_a949d66a43a7014ea1893875a343ed948"><div class="ttname"><a href="pwm_8h.html#a949d66a43a7014ea1893875a343ed948">PWM_GEN_EXT_0</a></div><div class="ttdeci">#define PWM_GEN_EXT_0</div><div class="ttdef"><b>Definition:</b> pwm.h:144</div></div>
<div class="ttc" id="apwm_8h_html_a9e2cd841eb589469e7f862b392d29088"><div class="ttname"><a href="pwm_8h.html#a9e2cd841eb589469e7f862b392d29088">PWM_GEN_0</a></div><div class="ttdeci">#define PWM_GEN_0</div><div class="ttdef"><b>Definition:</b> pwm.h:134</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga7904efa054c5e221ee9aa2e438f37100" name="ga7904efa054c5e221ee9aa2e438f37100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7904efa054c5e221ee9aa2e438f37100">&#9670;&#160;</a></span>PWM_IS_OUTPUT_ODD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PWM_IS_OUTPUT_ODD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_out_</td><td>)</td>
          <td>&#160;&#160;&#160;                                ((_out_) &amp; 0x00000001)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4563e3820191c9d6e73156340b715264" name="ga4563e3820191c9d6e73156340b715264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4563e3820191c9d6e73156340b715264">&#9670;&#160;</a></span>PWM_OUT_BADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PWM_OUT_BADDR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_mod_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_out_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;                                ((_mod_) + ((_out_) &amp; 0xFFFFFFC0))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6f57a49f895de360f84c363f608eebed" name="ga6f57a49f895de360f84c363f608eebed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f57a49f895de360f84c363f608eebed">&#9670;&#160;</a></span>PWMClockGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PWMClockGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current PWM clock configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current PWM clock configuration.</p>
<dl class="section note"><dt>Note</dt><dd>This function should not be used with TM4C123 devices. For TM4C123 devices, the <a class="el" href="group__sysctl__api.html#gaaccf3eef212a6be9e924103bd100f54f">SysCtlPWMClockGet()</a> function should be used.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the current PWM clock configuration; is one of <b>PWM_SYSCLK_DIV_1</b>, <b>PWM_SYSCLK_DIV_2</b>, <b>PWM_SYSCLK_DIV_4</b>, <b>PWM_SYSCLK_DIV_8</b>, <b>PWM_SYSCLK_DIV_16</b>, <b>PWM_SYSCLK_DIV_32</b>, or <b>PWM_SYSCLK_DIV_64</b>. </dd></dl>

</div>
</div>
<a id="gabe29ab284505972d4c172e6b33daabd9" name="gabe29ab284505972d4c172e6b33daabd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe29ab284505972d4c172e6b33daabd9">&#9670;&#160;</a></span>PWMClockSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMClockSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the PWM clock configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the configuration for the PWM clock; it must be one of <b>PWM_SYSCLK_DIV_1</b>, <b>PWM_SYSCLK_DIV_2</b>, <b>PWM_SYSCLK_DIV_4</b>, <b>PWM_SYSCLK_DIV_8</b>, <b>PWM_SYSCLK_DIV_16</b>, <b>PWM_SYSCLK_DIV_32</b>, or <b>PWM_SYSCLK_DIV_64</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the PWM clock divider as the PWM clock source. It also configures the clock frequency to the PWM module as a division of the system clock. This clock is used by the PWM module to generate PWM signals; its rate forms the basis for all PWM signals.</p>
<dl class="section note"><dt>Note</dt><dd>This function should not be used with TM4C123 devices. For TM4C123 devices, the <a class="el" href="group__sysctl__api.html#gaaccf3eef212a6be9e924103bd100f54f">SysCtlPWMClockGet()</a> function should be used.</dd>
<dd>
The clocking of the PWM is dependent upon the system clock rate as configured by <a class="el" href="group__sysctl__api.html#ga21032362a556673829fb41e4f057ec5a">SysCtlClockFreqSet()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga0330312868b4d7df496759563635690c" name="ga0330312868b4d7df496759563635690c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0330312868b4d7df496759563635690c">&#9670;&#160;</a></span>PWMDeadBandDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMDeadBandDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the PWM dead band output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to modify. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the dead band mode for the specified PWM generator. Doing so decouples the <b>OutA</b> and <b>OutB</b> signals.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gabe610ec6fd50251becf382a1479ca32f" name="gabe610ec6fd50251becf382a1479ca32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe610ec6fd50251becf382a1479ca32f">&#9670;&#160;</a></span>PWMDeadBandEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMDeadBandEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ui16Rise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ui16Fall</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables the PWM dead band output and sets the dead band delays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to modify. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui16Rise</td><td>specifies the width of delay from the rising edge. </td></tr>
    <tr><td class="paramname">ui16Fall</td><td>specifies the width of delay from the falling edge.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the dead bands for the specified PWM generator, where the dead bands are defined as the number of <b>PWM</b> clock ticks from the rising or falling edge of the generator's <b>OutA</b> signal. Note that this function causes the coupling of <b>OutB</b> to <b>OutA</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gaf389ca1c69300d556fdc5113cccf5060" name="gaf389ca1c69300d556fdc5113cccf5060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf389ca1c69300d556fdc5113cccf5060">&#9670;&#160;</a></span>PWMFaultIntClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMFaultIntClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the fault interrupt for a PWM module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the fault interrupt by writing to the appropriate bit of the interrupt status register for the selected PWM module.</p>
<p>This function clears only the FAULT0 interrupt and is retained for backwards compatibility. It is recommended that <a class="el" href="group__pwm__api.html#ga9c0e721a969daed808a148607859e21d">PWMFaultIntClearExt()</a> be used instead because it supports all fault interrupts supported on devices with and without extended PWM fault handling support.</p>
<dl class="section note"><dt>Note</dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga9c0e721a969daed808a148607859e21d" name="ga9c0e721a969daed808a148607859e21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c0e721a969daed808a148607859e21d">&#9670;&#160;</a></span>PWMFaultIntClearExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMFaultIntClearExt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32FaultInts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the fault interrupt for a PWM module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32FaultInts</td><td>specifies the fault interrupts to clear.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears one or more fault interrupts by writing to the appropriate bit of the PWM interrupt status register. The parameter <em>ui32FaultInts</em> must be the logical OR of any of <b>PWM_INT_FAULT0</b>, <b>PWM_INT_FAULT1</b>, <b>PWM_INT_FAULT2</b>, or <b>PWM_INT_FAULT3</b>.</p>
<p>The fault interrupts are derived by performing a logical OR of each of the configured fault trigger signals for a given generator. Therefore, these interrupts are not directly related to the four possible FAULTn inputs to the device but indicate that a fault has been signaled to one of the four possible PWM generators.</p>
<dl class="section note"><dt>Note</dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gada200e22c312dd4015e26717821ffb39" name="gada200e22c312dd4015e26717821ffb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada200e22c312dd4015e26717821ffb39">&#9670;&#160;</a></span>PWMFaultIntRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMFaultIntRegister </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>pfnIntHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers an interrupt handler for a fault condition detected in a PWM module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">pfnIntHandler</td><td>is a pointer to the function to be called when the PWM fault interrupt occurs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function ensures that the interrupt handler specified by <em>pfnIntHandler</em> is called when a fault interrupt is detected for the selected PWM module. This function also enables the PWM fault interrupt in the NVIC; the PWM fault interrupt must also be enabled at the module level using <a class="el" href="group__pwm__api.html#gaf66b481a351b0be5f06e163640319838">PWMIntEnable()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gaa5b9971717f517bdac7c1f1e3885e541" name="gaa5b9971717f517bdac7c1f1e3885e541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5b9971717f517bdac7c1f1e3885e541">&#9670;&#160;</a></span>PWMFaultIntUnregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMFaultIntUnregister </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the PWM fault condition interrupt handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function removes the interrupt handler for a PWM fault interrupt from the selected PWM module. This function also disables the PWM fault interrupt in the NVIC; the PWM fault interrupt must also be disabled at the module level using <a class="el" href="group__pwm__api.html#gacaca72e1bc8b2f041b6e6ad290d54a12">PWMIntDisable()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga4fb48f68ba82e698c6ce1913d5300754" name="ga4fb48f68ba82e698c6ce1913d5300754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fb48f68ba82e698c6ce1913d5300754">&#9670;&#160;</a></span>PWMGenConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMGenConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures a PWM generator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to configure. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the configuration for the PWM generator.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to set the mode of operation for a PWM generator. The counting mode, synchronization mode, and debug behavior are all configured. After configuration, the generator is left in the disabled state.</p>
<p>A PWM generator can count in two different modes: count down mode or count up/down mode. In count down mode, it counts from a value down to zero, and then resets to the preset value, producing left-aligned PWM signals (that is, the rising edge of the two PWM signals produced by the generator occur at the same time). In count up/down mode, it counts up from zero to the preset value, counts back down to zero, and then repeats the process, producing center-aligned PWM signals (that is, the middle of the high/low period of the PWM signals produced by the generator occurs at the same time).</p>
<p>When the PWM generator parameters (period and pulse width) are modified, their effect on the output PWM signals can be delayed. In synchronous mode, the parameter updates are not applied until a synchronization event occurs. This mode allows multiple parameters to be modified and take effect simultaneously, instead of one at a time. Additionally, parameters to multiple PWM generators in synchronous mode can be updated simultaneously, allowing them to be treated as if they were a unified generator. In non-synchronous mode, the parameter updates are not delayed until a synchronization event. In either mode, the parameter updates only occur when the counter is at zero to help prevent oddly formed PWM signals during the update (that is, a PWM pulse that is too short or too long).</p>
<p>The PWM generator can either pause or continue running when the processor is stopped via the debugger. If configured to pause, it continues to count until it reaches zero, at which point it pauses until the processor is restarted. If configured to continue running, it keeps counting as if nothing had happened.</p>
<p>The <em>ui32Config</em> parameter contains the desired configuration. It is the logical OR of the following:</p>
<ul>
<li><b>PWM_GEN_MODE_DOWN</b> or <b>PWM_GEN_MODE_UP_DOWN</b> to specify the counting mode</li>
<li><b>PWM_GEN_MODE_SYNC</b> or <b>PWM_GEN_MODE_NO_SYNC</b> to specify the counter load and comparator update synchronization mode</li>
<li><b>PWM_GEN_MODE_DBG_RUN</b> or <b>PWM_GEN_MODE_DBG_STOP</b> to specify the debug behavior</li>
<li><b>PWM_GEN_MODE_GEN_NO_SYNC</b>, <b>PWM_GEN_MODE_GEN_SYNC_LOCAL</b>, or <b>PWM_GEN_MODE_GEN_SYNC_GLOBAL</b> to specify the update synchronization mode for generator counting mode changes</li>
<li><b>PWM_GEN_MODE_DB_NO_SYNC</b>, <b>PWM_GEN_MODE_DB_SYNC_LOCAL</b>, or <b>PWM_GEN_MODE_DB_SYNC_GLOBAL</b> to specify the deadband parameter synchronization mode</li>
<li><b>PWM_GEN_MODE_FAULT_LATCHED</b> or <b>PWM_GEN_MODE_FAULT_UNLATCHED</b> to specify whether fault conditions are latched or not</li>
<li><b>PWM_GEN_MODE_FAULT_MINPER</b> or <b>PWM_GEN_MODE_FAULT_NO_MINPER</b> to specify whether minimum fault period support is required</li>
<li><b>PWM_GEN_MODE_FAULT_EXT</b> or <b>PWM_GEN_MODE_FAULT_LEGACY</b> to specify whether extended fault source selection support is enabled or not</li>
</ul>
<p>Setting <b>PWM_GEN_MODE_FAULT_MINPER</b> allows an application to set the minimum duration of a PWM fault signal. Faults are signaled for at least this time even if the external fault pin deasserts earlier. Care should be taken when using this mode because during the fault signal period, the fault interrupt from the PWM generator remains asserted. The fault interrupt handler may, therefore, reenter immediately if it exits prior to expiration of the fault timer.</p>
<dl class="section note"><dt>Note</dt><dd>Changes to the counter mode affect the period of the PWM signals produced. <a class="el" href="group__pwm__api.html#ga0ec9d188f8e72f597f4f5bf41152468d">PWMGenPeriodSet()</a> and <a class="el" href="group__pwm__api.html#ga2abde7fc411bf9cad8de0c5dc070c78c">PWMPulseWidthSet()</a> should be called after any changes to the counter mode of a generator.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga2829ffb434e65a7aa27ee69977fdc122" name="ga2829ffb434e65a7aa27ee69977fdc122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2829ffb434e65a7aa27ee69977fdc122">&#9670;&#160;</a></span>PWMGenDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMGenDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the timer/counter for a PWM generator block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to be disabled. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function blocks the PWM clock from driving the timer/counter for the specified generator block.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gac83fa6b41c14ed89bb8c1882c59ac190" name="gac83fa6b41c14ed89bb8c1882c59ac190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac83fa6b41c14ed89bb8c1882c59ac190">&#9670;&#160;</a></span>PWMGenEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMGenEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables the timer/counter for a PWM generator block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to be enabled. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the PWM clock to drive the timer/counter for the specified generator block.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga3c00a35459dd8714d57bb35c1b2e5621" name="ga3c00a35459dd8714d57bb35c1b2e5621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c00a35459dd8714d57bb35c1b2e5621">&#9670;&#160;</a></span>PWMGenFaultClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMGenFaultClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32FaultTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears one or more latched fault triggers for a given PWM generator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator for which fault trigger states are being queried. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32Group</td><td>indicates the subset of faults that are being queried. This parameter must be <b>PWM_FAULT_GROUP_0</b> or <b>PWM_FAULT_GROUP_1</b>. </td></tr>
    <tr><td class="paramname">ui32FaultTriggers</td><td>is the set of fault triggers which are to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows an application to clear the fault triggers for a given PWM generator. This function is only required if <a class="el" href="group__pwm__api.html#ga4fb48f68ba82e698c6ce1913d5300754">PWMGenConfigure()</a> has previously been called with flag <b>PWM_GEN_MODE_FAULT_LATCHED</b> in parameter <em>ui32Config</em>.</p>
<dl class="section note"><dt>Note</dt><dd>This function is only available on devices supporting extended PWM fault handling.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga16ca060d2c4e997682912cba1d6d1962" name="ga16ca060d2c4e997682912cba1d6d1962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16ca060d2c4e997682912cba1d6d1962">&#9670;&#160;</a></span>PWMGenFaultConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMGenFaultConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32MinFaultPeriod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32FaultSenses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the minimum fault period and fault pin senses for a given PWM generator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator for which fault configuration is being set. This function must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32MinFaultPeriod</td><td>is the minimum fault active period expressed in PWM clock cycles. </td></tr>
    <tr><td class="paramname">ui32FaultSenses</td><td>indicates which sense of each FAULT input should be considered the `&lsquo;asserted&rsquo;' state. Valid values are logical OR combinations of <b>PWM_FAULTn_SENSE_HIGH</b> and <b>PWM_FAULTn_SENSE_LOW</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the minimum fault period for a given generator along with the sense of each of the 4 possible fault inputs. The minimum fault period is expressed in PWM clock cycles and takes effect only if <a class="el" href="group__pwm__api.html#ga4fb48f68ba82e698c6ce1913d5300754">PWMGenConfigure()</a> is called with flag <b>PWM_GEN_MODE_FAULT_PER</b> set in the <em>ui32Config</em> parameter. When a fault input is asserted, the minimum fault period timer ensures that it remains asserted for at least the number of clock cycles specified.</p>
<dl class="section note"><dt>Note</dt><dd>This function is only available on devices supporting extended PWM fault handling.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gaf2cd851dc65dccee7c2c885f15bbfc4a" name="gaf2cd851dc65dccee7c2c885f15bbfc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2cd851dc65dccee7c2c885f15bbfc4a">&#9670;&#160;</a></span>PWMGenFaultStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PWMGenFaultStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current state of the fault triggers for a given PWM generator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator for which fault trigger states are being queried. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32Group</td><td>indicates the subset of faults that are being queried. This parameter must be <b>PWM_FAULT_GROUP_0</b> or <b>PWM_FAULT_GROUP_1</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows an application to query the current state of each of the fault trigger inputs to a given PWM generator. The current state of each fault trigger input is returned unless <a class="el" href="group__pwm__api.html#ga4fb48f68ba82e698c6ce1913d5300754">PWMGenConfigure()</a> has previously been called with flag <b>PWM_GEN_MODE_FAULT_LATCHED</b> in the <em>ui32Config</em> parameter, in which case the returned status is the latched fault trigger status.</p>
<p>If latched faults are configured, the application must call <a class="el" href="group__pwm__api.html#ga3c00a35459dd8714d57bb35c1b2e5621">PWMGenFaultClear()</a> to clear each trigger.</p>
<dl class="section note"><dt>Note</dt><dd>This function is only available on devices supporting extended PWM fault handling.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the current state of the fault triggers for the given PWM generator. A set bit indicates that the associated trigger is active. For <b>PWM_FAULT_GROUP_0</b>, the returned value is a logical OR of <b>PWM_FAULT_FAULT0</b>, <b>PWM_FAULT_FAULT1</b>, <b>PWM_FAULT_FAULT2</b>, or <b>PWM_FAULT_FAULT3</b>. For <b>PWM_FAULT_GROUP_1</b>, the return value is the logical OR of <b>PWM_FAULT_DCMP0</b>, <b>PWM_FAULT_DCMP1</b>, <b>PWM_FAULT_DCMP2</b>, <b>PWM_FAULT_DCMP3</b>, <b>PWM_FAULT_DCMP4</b>, <b>PWM_FAULT_DCMP5</b>, <b>PWM_FAULT_DCMP6</b>, or <b>PWM_FAULT_DCMP7</b>. </dd></dl>

</div>
</div>
<a id="ga59e1b382bd20206868f6bb0af0af98df" name="ga59e1b382bd20206868f6bb0af0af98df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59e1b382bd20206868f6bb0af0af98df">&#9670;&#160;</a></span>PWMGenFaultTriggerGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PWMGenFaultTriggerGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the set of fault triggers currently configured for a given PWM generator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator for which fault triggers are being queried. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32Group</td><td>indicates the subset of faults that are being queried. This parameter must be <b>PWM_FAULT_GROUP_0</b> or <b>PWM_FAULT_GROUP_1</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows an application to query the current set of inputs that contribute to the generation of a fault condition to a given PWM generator.</p>
<dl class="section note"><dt>Note</dt><dd>This function is only available on devices supporting extended PWM fault handling.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the current fault triggers configured for the fault group provided. For <b>PWM_FAULT_GROUP_0</b>, the returned value is a logical OR of <b>PWM_FAULT_FAULT0</b>, <b>PWM_FAULT_FAULT1</b>, <b>PWM_FAULT_FAULT2</b>, or <b>PWM_FAULT_FAULT3</b>. For <b>PWM_FAULT_GROUP_1</b>, the return value is the logical OR of <b>PWM_FAULT_DCMP0</b>, <b>PWM_FAULT_DCMP1</b>, <b>PWM_FAULT_DCMP2</b>, <b>PWM_FAULT_DCMP3</b>, <b>PWM_FAULT_DCMP4</b>, <b>PWM_FAULT_DCMP5</b>, <b>PWM_FAULT_DCMP6</b>, or <b>PWM_FAULT_DCMP7</b>. </dd></dl>

</div>
</div>
<a id="gae7fb9968efcd45b0525dc1f3bca86819" name="gae7fb9968efcd45b0525dc1f3bca86819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7fb9968efcd45b0525dc1f3bca86819">&#9670;&#160;</a></span>PWMGenFaultTriggerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMGenFaultTriggerSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32FaultTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the set of fault triggers for a given PWM generator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator for which fault triggers are being set. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32Group</td><td>indicates the subset of possible faults that are to be configured. This parameter must be <b>PWM_FAULT_GROUP_0</b> or <b>PWM_FAULT_GROUP_1</b>. </td></tr>
    <tr><td class="paramname">ui32FaultTriggers</td><td>defines the set of inputs that are to contribute towards generation of the fault signal to the given PWM generator. For <b>PWM_FAULT_GROUP_0</b>, this is the logical OR of <b>PWM_FAULT_FAULT0</b>, <b>PWM_FAULT_FAULT1</b>, <b>PWM_FAULT_FAULT2</b>, or <b>PWM_FAULT_FAULT3</b>. For <b>PWM_FAULT_GROUP_1</b>, this is the logical OR of <b>PWM_FAULT_DCMP0</b>, <b>PWM_FAULT_DCMP1</b>, <b>PWM_FAULT_DCMP2</b>, <b>PWM_FAULT_DCMP3</b>, <b>PWM_FAULT_DCMP4</b>, <b>PWM_FAULT_DCMP5</b>, <b>PWM_FAULT_DCMP6</b>, or <b>PWM_FAULT_DCMP7</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows selection of the set of fault inputs that is combined to generate a fault condition to a given PWM generator. By default, all generators use only FAULT0 (for backwards compatibility) but if <a class="el" href="group__pwm__api.html#ga4fb48f68ba82e698c6ce1913d5300754">PWMGenConfigure()</a> is called with flag <b>PWM_GEN_MODE_FAULT_SRC</b> in the <em>ui32Config</em> parameter, extended fault handling is enabled and this function must be called to configure the fault triggers.</p>
<p>The fault signal to the PWM generator is generated by ORing together each of the signals specified in the <em>ui32FaultTriggers</em> parameter after having adjusted the sense of each FAULTn input based on the configuration previously set using a call to <a class="el" href="group__pwm__api.html#ga16ca060d2c4e997682912cba1d6d1962">PWMGenFaultConfigure()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function is only available on devices supporting extended PWM fault handling.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga0d4748e1865ceae4814aef2296a9604a" name="ga0d4748e1865ceae4814aef2296a9604a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d4748e1865ceae4814aef2296a9604a">&#9670;&#160;</a></span>PWMGenIntClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMGenIntClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Ints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the specified interrupt(s) for the specified PWM generator block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to query. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32Ints</td><td>specifies the interrupts to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the specified interrupt(s) by writing a 1 to the specified bits of the interrupt status register for the specified PWM generator. The <em>ui32Ints</em> parameter is the logical OR of <b>PWM_INT_CNT_ZERO</b>, <b>PWM_INT_CNT_LOAD</b>, <b>PWM_INT_CNT_AU</b>, <b>PWM_INT_CNT_AD</b>, <b>PWM_INT_CNT_BU</b>, or <b>PWM_INT_CNT_BD</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga1bd27374e6dce2e1a2689166b79be9f6" name="ga1bd27374e6dce2e1a2689166b79be9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bd27374e6dce2e1a2689166b79be9f6">&#9670;&#160;</a></span>PWMGenIntRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMGenIntRegister </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>pfnIntHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers an interrupt handler for the specified PWM generator block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator in question. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">pfnIntHandler</td><td>is a pointer to the function to be called when the PWM generator interrupt occurs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function ensures that the interrupt handler specified by <em>pfnIntHandler</em> is called when an interrupt is detected for the specified PWM generator block. This function also enables the corresponding PWM generator interrupt in the interrupt controller; individual generator interrupts and interrupt sources must be enabled with <a class="el" href="group__pwm__api.html#gaf66b481a351b0be5f06e163640319838">PWMIntEnable()</a> and <a class="el" href="group__pwm__api.html#ga31055ec13555e774fa6702e35b774518">PWMGenIntTrigEnable()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga645372a9dd99a0683d7c8e53006357ed" name="ga645372a9dd99a0683d7c8e53006357ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga645372a9dd99a0683d7c8e53006357ed">&#9670;&#160;</a></span>PWMGenIntStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PWMGenIntStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMasked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets interrupt status for the specified PWM generator block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to query. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">bMasked</td><td>specifies whether masked or raw interrupt status is returned.</td></tr>
  </table>
  </dd>
</dl>
<p>If <em>bMasked</em> is set as <b>true</b>, then the masked interrupt status is returned; otherwise, the raw interrupt status is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the contents of the interrupt status register or the contents of the raw interrupt status register for the specified PWM generator. </dd></dl>

</div>
</div>
<a id="gafdd8f3c8343e5b06916bb6ba5ead9533" name="gafdd8f3c8343e5b06916bb6ba5ead9533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdd8f3c8343e5b06916bb6ba5ead9533">&#9670;&#160;</a></span>PWMGenIntTrigDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMGenIntTrigDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntTrig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables interrupts for the specified PWM generator block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to have interrupts and triggers disabled. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32IntTrig</td><td>specifies the interrupts and triggers to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function masks the specified interrupt(s) and trigger(s) by clearing the specified bits of the interrupt/trigger enable register for the specified PWM generator. The <em>ui32IntTrig</em> parameter is the logical OR of <b>PWM_INT_CNT_ZERO</b>, <b>PWM_INT_CNT_LOAD</b>, <b>PWM_INT_CNT_AU</b>, <b>PWM_INT_CNT_AD</b>, <b>PWM_INT_CNT_BU</b>, <b>PWM_INT_CNT_BD</b>, <b>PWM_TR_CNT_ZERO</b>, <b>PWM_TR_CNT_LOAD</b>, <b>PWM_TR_CNT_AU</b>, <b>PWM_TR_CNT_AD</b>, <b>PWM_TR_CNT_BU</b>, or <b>PWM_TR_CNT_BD</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga31055ec13555e774fa6702e35b774518" name="ga31055ec13555e774fa6702e35b774518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31055ec13555e774fa6702e35b774518">&#9670;&#160;</a></span>PWMGenIntTrigEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMGenIntTrigEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntTrig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables interrupts and triggers for the specified PWM generator block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to have interrupts and triggers enabled. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32IntTrig</td><td>specifies the interrupts and triggers to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function unmasks the specified interrupt(s) and trigger(s) by setting the specified bits of the interrupt/trigger enable register for the specified PWM generator. The <em>ui32IntTrig</em> parameter is the logical OR of <b>PWM_INT_CNT_ZERO</b>, <b>PWM_INT_CNT_LOAD</b>, <b>PWM_INT_CNT_AU</b>, <b>PWM_INT_CNT_AD</b>, <b>PWM_INT_CNT_BU</b>, <b>PWM_INT_CNT_BD</b>, <b>PWM_TR_CNT_ZERO</b>, <b>PWM_TR_CNT_LOAD</b>, <b>PWM_TR_CNT_AU</b>, <b>PWM_TR_CNT_AD</b>, <b>PWM_TR_CNT_BU</b>, or <b>PWM_TR_CNT_BD</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga93c72c556d0febbd7d641df12f30d7b1" name="ga93c72c556d0febbd7d641df12f30d7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93c72c556d0febbd7d641df12f30d7b1">&#9670;&#160;</a></span>PWMGenIntUnregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMGenIntUnregister </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes an interrupt handler for the specified PWM generator block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator in question. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function unregisters the interrupt handler for the specified PWM generator block. This function also disables the corresponding PWM generator interrupt in the interrupt controller; individual generator interrupts and interrupt sources must be disabled with <a class="el" href="group__pwm__api.html#gacaca72e1bc8b2f041b6e6ad290d54a12">PWMIntDisable()</a> and <a class="el" href="group__pwm__api.html#gafdd8f3c8343e5b06916bb6ba5ead9533">PWMGenIntTrigDisable()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga318c7e9cfc0c4abc0c1efc3154bc0810" name="ga318c7e9cfc0c4abc0c1efc3154bc0810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga318c7e9cfc0c4abc0c1efc3154bc0810">&#9670;&#160;</a></span>PWMGenPeriodGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PWMGenPeriodGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the period of a PWM generator block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to query. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the period of the specified PWM generator block. The period of the generator block is defined as the number of PWM clock ticks between pulses on the generator block zero signal.</p>
<p>If the update of the counter for the specified PWM generator has yet to be completed, the value returned may not be the active period. The value returned is the programmed period, measured in PWM clock ticks.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the programmed period of the specified generator block in PWM clock ticks. </dd></dl>

</div>
</div>
<a id="ga0ec9d188f8e72f597f4f5bf41152468d" name="ga0ec9d188f8e72f597f4f5bf41152468d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ec9d188f8e72f597f4f5bf41152468d">&#9670;&#160;</a></span>PWMGenPeriodSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMGenPeriodSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the period of a PWM generator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to be modified. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32Period</td><td>specifies the period of PWM generator output, measured in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the period of the specified PWM generator block, where the period of the generator block is defined as the number of PWM clock ticks between pulses on the generator block zero signal.</p>
<dl class="section note"><dt>Note</dt><dd>Any subsequent calls made to this function before an update occurs cause the previous values to be overwritten.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gacaca72e1bc8b2f041b6e6ad290d54a12" name="gacaca72e1bc8b2f041b6e6ad290d54a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacaca72e1bc8b2f041b6e6ad290d54a12">&#9670;&#160;</a></span>PWMIntDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMIntDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32GenFault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables generator and fault interrupts for a PWM module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32GenFault</td><td>contains the interrupts to be disabled. This parameter must be a logical OR of any of <b>PWM_INT_GEN_0</b>, <b>PWM_INT_GEN_1</b>, <b>PWM_INT_GEN_2</b>, <b>PWM_INT_GEN_3</b>, <b>PWM_INT_FAULT0</b>, <b>PWM_INT_FAULT1</b>, <b>PWM_INT_FAULT2</b>, or <b>PWM_INT_FAULT3</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function masks the specified interrupt(s) by clearing the specified bits of the interrupt enable register for the selected PWM module.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gaf66b481a351b0be5f06e163640319838" name="gaf66b481a351b0be5f06e163640319838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf66b481a351b0be5f06e163640319838">&#9670;&#160;</a></span>PWMIntEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMIntEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32GenFault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables generator and fault interrupts for a PWM module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32GenFault</td><td>contains the interrupts to be enabled. This parameter must be a logical OR of any of <b>PWM_INT_GEN_0</b>, <b>PWM_INT_GEN_1</b>, <b>PWM_INT_GEN_2</b>, <b>PWM_INT_GEN_3</b>, <b>PWM_INT_FAULT0</b>, <b>PWM_INT_FAULT1</b>, <b>PWM_INT_FAULT2</b>, or <b>PWM_INT_FAULT3</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function unmasks the specified interrupt(s) by setting the specified bits of the interrupt enable register for the selected PWM module.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gac90f2873671ff65e9225d8238e068a14" name="gac90f2873671ff65e9225d8238e068a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac90f2873671ff65e9225d8238e068a14">&#9670;&#160;</a></span>PWMIntStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PWMIntStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMasked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the interrupt status for a PWM module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">bMasked</td><td>specifies whether masked or raw interrupt status is returned.</td></tr>
  </table>
  </dd>
</dl>
<p>If <em>bMasked</em> is set as <b>true</b>, then the masked interrupt status is returned; otherwise, the raw interrupt status is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The current interrupt status, enumerated as a bit field of <b>PWM_INT_GEN_0</b>, <b>PWM_INT_GEN_1</b>, <b>PWM_INT_GEN_2</b>, <b>PWM_INT_GEN_3</b>, <b>PWM_INT_FAULT0</b>, <b>PWM_INT_FAULT1</b>, <b>PWM_INT_FAULT2</b>, and <b>PWM_INT_FAULT3</b>. </dd></dl>

</div>
</div>
<a id="ga10e1cb93f663c916cf5403e29e1be898" name="ga10e1cb93f663c916cf5403e29e1be898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10e1cb93f663c916cf5403e29e1be898">&#9670;&#160;</a></span>PWMOutputFault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMOutputFault </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32PWMOutBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bFaultSuppress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies the state of PWM outputs in response to a fault condition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32PWMOutBits</td><td>are the PWM outputs to be modified. This parameter must be the logical OR of any of <b>PWM_OUT_0_BIT</b>, <b>PWM_OUT_1_BIT</b>, <b>PWM_OUT_2_BIT</b>, <b>PWM_OUT_3_BIT</b>, <b>PWM_OUT_4_BIT</b>, <b>PWM_OUT_5_BIT</b>, <b>PWM_OUT_6_BIT</b>, or <b>PWM_OUT_7_BIT</b>. </td></tr>
    <tr><td class="paramname">bFaultSuppress</td><td>determines if the signal is suppressed or passed through during an active fault condition.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the fault handling characteristics of the selected PWM outputs. The outputs are selected using the parameter <em>ui32PWMOutBits</em>. The parameter <em>bFaultSuppress</em> determines the fault handling characteristics for the selected outputs. If <em>bFaultSuppress</em> is <b>true</b>, then the selected outputs are made inactive. If <em>bFaultSuppress</em> is <b>false</b>, then the selected outputs are unaffected by the detected fault.</p>
<p>On devices supporting extended PWM fault handling, the state the affected output pins are driven to can be configured with <a class="el" href="group__pwm__api.html#ga35b6c40b99278f7d78c186cd275b7a05">PWMOutputFaultLevel()</a>. If not configured, or if the device does not support extended PWM fault handling, affected outputs are driven low on a fault condition.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga35b6c40b99278f7d78c186cd275b7a05" name="ga35b6c40b99278f7d78c186cd275b7a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35b6c40b99278f7d78c186cd275b7a05">&#9670;&#160;</a></span>PWMOutputFaultLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMOutputFaultLevel </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32PWMOutBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDriveHigh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies the level of PWM outputs suppressed in response to a fault condition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32PWMOutBits</td><td>are the PWM outputs to be modified. This parameter must be the logical OR of any of <b>PWM_OUT_0_BIT</b>, <b>PWM_OUT_1_BIT</b>, <b>PWM_OUT_2_BIT</b>, <b>PWM_OUT_3_BIT</b>, <b>PWM_OUT_4_BIT</b>, <b>PWM_OUT_5_BIT</b>, <b>PWM_OUT_6_BIT</b>, or <b>PWM_OUT_7_BIT</b>. </td></tr>
    <tr><td class="paramname">bDriveHigh</td><td>determines if the signal is driven high or low during an active fault condition.</td></tr>
  </table>
  </dd>
</dl>
<p>This function determines whether a PWM output pin that is suppressed in response to a fault condition is driven high or low. The affected outputs are selected using the parameter <em>ui32PWMOutBits</em>. The parameter <em>bDriveHigh</em> determines the output level for the pins identified by <em>ui32PWMOutBits</em>. If <em>bDriveHigh</em> is <b>true</b> then the selected outputs are driven high when a fault is detected. If it is <em>false</em>, the pins are driven low.</p>
<p>In a fault condition, pins which have not been configured to be suppressed via a call to <a class="el" href="group__pwm__api.html#ga10e1cb93f663c916cf5403e29e1be898">PWMOutputFault()</a> are unaffected by this function.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only on devices which support extended PWM fault handling.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gaf233159a77a070f2dc60d50da3939ba9" name="gaf233159a77a070f2dc60d50da3939ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf233159a77a070f2dc60d50da3939ba9">&#9670;&#160;</a></span>PWMOutputInvert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMOutputInvert </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32PWMOutBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInvert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects the inversion mode for PWM outputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32PWMOutBits</td><td>are the PWM outputs to be modified. This parameter must be the logical OR of any of <b>PWM_OUT_0_BIT</b>, <b>PWM_OUT_1_BIT</b>, <b>PWM_OUT_2_BIT</b>, <b>PWM_OUT_3_BIT</b>, <b>PWM_OUT_4_BIT</b>, <b>PWM_OUT_5_BIT</b>, <b>PWM_OUT_6_BIT</b>, or <b>PWM_OUT_7_BIT</b>. </td></tr>
    <tr><td class="paramname">bInvert</td><td>determines if the signal is inverted or passed through.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to select the inversion mode for the selected PWM outputs. The outputs are selected using the parameter <em>ui32PWMOutBits</em>. The parameter <em>bInvert</em> determines the inversion mode for the selected outputs. If <em>bInvert</em> is <b>true</b>, this function causes the specified PWM output signals to be inverted or made active low. If <em>bInvert</em> is <b>false</b>, the specified outputs are passed through as is or made active high.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga372c69ae52fe1136454b60230f38beb1" name="ga372c69ae52fe1136454b60230f38beb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga372c69ae52fe1136454b60230f38beb1">&#9670;&#160;</a></span>PWMOutputState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMOutputState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32PWMOutBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables or disables PWM outputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32PWMOutBits</td><td>are the PWM outputs to be modified. This parameter must be the logical OR of any of <b>PWM_OUT_0_BIT</b>, <b>PWM_OUT_1_BIT</b>, <b>PWM_OUT_2_BIT</b>, <b>PWM_OUT_3_BIT</b>, <b>PWM_OUT_4_BIT</b>, <b>PWM_OUT_5_BIT</b>, <b>PWM_OUT_6_BIT</b>, or <b>PWM_OUT_7_BIT</b>. </td></tr>
    <tr><td class="paramname">bEnable</td><td>determines if the signal is enabled or disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables or disables the selected PWM outputs. The outputs are selected using the parameter <em>ui32PWMOutBits</em>. The parameter <em>bEnable</em> determines the state of the selected outputs. If <em>bEnable</em> is <b>true</b>, then the selected PWM outputs are enabled, or placed in the active state. If <em>bEnable</em> is <b>false</b>, then the selected outputs are disabled or placed in the inactive state.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga77b64a04eb1bd9daf99c10d549a8ada5" name="ga77b64a04eb1bd9daf99c10d549a8ada5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77b64a04eb1bd9daf99c10d549a8ada5">&#9670;&#160;</a></span>PWMOutputUpdateMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMOutputUpdateMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32PWMOutBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the update mode or synchronization mode to the PWM outputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32PWMOutBits</td><td>are the PWM outputs to be modified. This parameter must be the logical OR of any of <b>PWM_OUT_0_BIT</b>, <b>PWM_OUT_1_BIT</b>, <b>PWM_OUT_2_BIT</b>, <b>PWM_OUT_3_BIT</b>, <b>PWM_OUT_4_BIT</b>, <b>PWM_OUT_5_BIT</b>, <b>PWM_OUT_6_BIT</b>, or <b>PWM_OUT_7_BIT</b>. </td></tr>
    <tr><td class="paramname">ui32Mode</td><td>specifies the enable update mode to use when enabling or disabling PWM outputs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets one of three possible update modes to enable or disable the requested PWM outputs. The <em>ui32Mode</em> parameter controls when changes made via calls to <a class="el" href="group__pwm__api.html#ga372c69ae52fe1136454b60230f38beb1">PWMOutputState()</a> take effect. Possible values are:</p>
<ul>
<li><b>PWM_OUTPUT_MODE_NO_SYNC</b>, which enables/disables changes to take effect immediately.</li>
<li><b>PWM_OUTPUT_MODE_SYNC_LOCAL</b>, which causes changes to take effect when the local PWM generator's count next reaches 0.</li>
<li><b>PWM_OUTPUT_MODE_SYNC_GLOBAL</b>, which causes changes to take effect when the local PWM generator's count next reaches 0 following a call to <a class="el" href="group__pwm__api.html#ga32a04801267751f323f528cd3d5f2da5">PWMSyncUpdate()</a> which specifies the same generator in its <em>ui32GenBits</em> parameter.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function is only available on Snowflake class devices.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gae361688d19da3c776f82e31607392f3f" name="gae361688d19da3c776f82e31607392f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae361688d19da3c776f82e31607392f3f">&#9670;&#160;</a></span>PWMPulseWidthGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PWMPulseWidthGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32PWMOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the pulse width of a PWM output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32PWMOut</td><td>is the PWM output to query. This parameter must be one of <b>PWM_OUT_0</b>, <b>PWM_OUT_1</b>, <b>PWM_OUT_2</b>, <b>PWM_OUT_3</b>, <b>PWM_OUT_4</b>, <b>PWM_OUT_5</b>, <b>PWM_OUT_6</b>, or <b>PWM_OUT_7</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the currently programmed pulse width for the specified PWM output. If the update of the comparator for the specified output has yet to be completed, the value returned may not be the active pulse width. The value returned is the programmed pulse width, measured in PWM clock ticks.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the width of the pulse in PWM clock ticks. </dd></dl>

</div>
</div>
<a id="ga2abde7fc411bf9cad8de0c5dc070c78c" name="ga2abde7fc411bf9cad8de0c5dc070c78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2abde7fc411bf9cad8de0c5dc070c78c">&#9670;&#160;</a></span>PWMPulseWidthSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMPulseWidthSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32PWMOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the pulse width for the specified PWM output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32PWMOut</td><td>is the PWM output to modify. This parameter must be one of <b>PWM_OUT_0</b>, <b>PWM_OUT_1</b>, <b>PWM_OUT_2</b>, <b>PWM_OUT_3</b>, <b>PWM_OUT_4</b>, <b>PWM_OUT_5</b>, <b>PWM_OUT_6</b>, or <b>PWM_OUT_7</b>. </td></tr>
    <tr><td class="paramname">ui32Width</td><td>specifies the width of the positive portion of the pulse.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the pulse width for the specified PWM output, where the pulse width is defined as the number of PWM clock ticks.</p>
<dl class="section note"><dt>Note</dt><dd>Any subsequent calls made to this function before an update occurs cause the previous values to be overwritten.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gadd7281936c715b7286746bbae6c24a6a" name="gadd7281936c715b7286746bbae6c24a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd7281936c715b7286746bbae6c24a6a">&#9670;&#160;</a></span>PWMSyncTimeBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMSyncTimeBase </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32GenBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronizes the counters in one or multiple PWM generator blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32GenBits</td><td>are the PWM generator blocks to be synchronized. This parameter must be the logical OR of any of <b>PWM_GEN_0_BIT</b>, <b>PWM_GEN_1_BIT</b>, <b>PWM_GEN_2_BIT</b>, or <b>PWM_GEN_3_BIT</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>For the selected PWM module, this function synchronizes the time base of the generator blocks by causing the specified generator counters to be reset to zero.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga32a04801267751f323f528cd3d5f2da5" name="ga32a04801267751f323f528cd3d5f2da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32a04801267751f323f528cd3d5f2da5">&#9670;&#160;</a></span>PWMSyncUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWMSyncUpdate </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32GenBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronizes all pending updates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32GenBits</td><td>are the PWM generator blocks to be updated. This parameter must be the logical OR of any of <b>PWM_GEN_0_BIT</b>, <b>PWM_GEN_1_BIT</b>, <b>PWM_GEN_2_BIT</b>, or <b>PWM_GEN_3_BIT</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>For the selected PWM generators, this function causes all queued updates to the period or pulse width to be applied the next time the corresponding counter becomes zero.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
